[이미지 & 영상 다루기](https://opencv-python.readthedocs.io/en/latest/doc/01.imageStart/imageStart.html#id2)

# openCV 활용

```python
!pip install opencv-python
import cv2
cv2.__version__

import os
print(os.getcwd())

img_file = '../../img.jpg'
img = cv2.imread(img_file)

cv2.imshow('image', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
import cv2

fname = '../../img.jpg'

original = cv2.imread(fname, cv2.IMREAD_COLOR)
gray = cv2.imread(fname, cv2.IMREAD_GRAYSCALE)
unchange = cv2.imread(fname, cv2.IMREAD_UNCHANGED)

cv2.imshow('Original', original)
cv2.imshow('Gray', gray)
cv2.imshow('Unchange', unchange)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
# 동영상 출력
# -*-coding: utf-8 -*-
import cv2

# cap 이 정상적으로 open이 되었는지 확인하기 위해서 cap.isOpen() 으로 확인가능
video_file = "../../video.mp4"

cap = cv2.VideoCapture(video_file)

# cap.get(prodId)/cap.set(propId, value)을 통해서 속성 변경이 가능.
# 3은 width, 4는 heigh

print('width: {0}, height: {1}'.format(cap.get(3),cap.get(4)))
cap.set(3,320)
cap.set(4,240)

while(True):
    # ret : frame capture결과(boolean)
    # frame : Capture한 frame
    ret, frame = cap.read()

#     if (ret):
#         # image를 Grayscale로 Convert함.
#         gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

# #         cv2.imshow('frame', gray)
#         cv2.imshow('frame', frame) # 컬러 
#         if cv2.waitKey(1) & 0xFF == ord('q'):
#             break

    if not ret: # else 혹은 ret이 false일 때 break를 카메라 아닌 동영상 출력 시에는 적어주어야 함. 
        print("Error: Failed to grab frame.")
        break
        # image를 Grayscale로 Convert함.
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

#         cv2.imshow('frame', gray)
    cv2.imshow('frame', frame) # 컬러 
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
```

```python
# 색 공간 변화
import cv2
import numpy as np

img_file = '../../img.jpg'

img = cv2.imread(img_file)
# cv2에서는 bgr 순 - 그 당시 카메라가 bgr로 주로 써서
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # convert

cv2.imshow('img', img)
cv2.imshow('gray', gray)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
import matplotlib.pyplot as plt

img_file = '../../img.jpg'
img = cv2.imread(img_file)
img_cvtColor_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

plt.imshow(img_cvtColor_rgb, cmap='gray') # cmap=plt.cm.gray
plt.show()
```
matplotlib 사용시 BGR 변환 작업 필요 - 이후 cv 활용

# 도형 그리기

```python
# 빈 스케치북 그리기
import cv2
import numpy as np
# 세로 480 x 가로 640 , 3 channel 에 해당하는 스케치북 만들기 / 가로 세로 순 아님 세로 가로 순
img = np.zeros((480, 640, 3), dtype=np.uint8)                           # 현재 0 으로 채워져서 검정색
#img[:] = (255, 255, 255)  # 전체 공간을 흰색으로 채우기 - opencv BGR
# img[:] = (123, 245, 17)      # 전체 공간을 파란색으로 채우기
#img[:] = (0, 0, 255)      # 전체 공간을 빨간색으로 채우기 BGR 순
img[120:240, 240:360] = (0, 0, 255) # 특정 공간만 빨간색으로 채워졌음
img[240:360, 360:480] = (0, 255, 0) 

cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
# 선 그리기
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)
img[120:240, 240:360] = (0, 0, 255)
img[240:360, 360:480] = (0, 255, 0)

color = (0, 255, 255)
thickness = 3

cv2.line(img, (50, 100), (400, 50), color, thickness, cv2.LINE_4)
cv2.line(img, (50, 200), (400, 150), color, thickness, cv2.LINE_8)
cv2.line(img, (50, 300), (400, 250), color, thickness, cv2.LINE_AA) # anti-aliasing

cv2.imshow('img', img)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
# 원 그리기
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)

c = (0, 255, 255)
t = -1 # 안쪽 채우기 or cv2.FILLED
r = 50
cv2.circle(img,(240,320), r, c, t, cv2.LINE_AA)

cv2.imshow('img', img)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
# 사각형 그리기
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)

c = (0, 255, 255)
t = 40
cv2.rectangle(img,(100, 200), (300, 30), c, t, cv2.LINE_AA)

cv2.imshow('img', img)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
# 다각형 그리기
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)

c = (0, 255, 255)
t = -1
pts = np.array([[100,50], [200,300], [70,200], [50,100]], np.int32)
pts = pts.reshape((-1, 1, 2))
cv2.polylines(img, [pts], True, (225,125,255))

cv2.imshow('img', img)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
# 이미지 text 추가
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)
img1 = np.zeros((480, 640, 3), dtype=np.uint8)

c = (0, 255, 255)
t = 2
s = 1 # scale

# 폰트 종류
cv2.putText(img, 'Coding Simplex', (20, 50), cv2.FONT_HERSHEY_SIMPLEX, s, c, t)
cv2.putText(img, 'Coding Simplex', (20, 150), cv2.FONT_HERSHEY_PLAIN, s, c, t)
cv2.putText(img, 'Coding Simplex', (20, 250), cv2.FONT_HERSHEY_SCRIPT_SIMPLEX, s, c, t)
cv2.putText(img, 'Coding Simplex', (20, 350), cv2.FONT_HERSHEY_TRIPLEX, s, c, t)
cv2.putText(img, 'Coding Simplex', (20, 450), cv2.FONT_HERSHEY_TRIPLEX | cv2.FONT_ITALIC, s, c, t) # 이탤릭체는 같이 사용 

# 한글은 지원이 안되서 그림을 그리듯 편법으로
# PIL ( Python Image Library)
from PIL import ImageFont, ImageDraw, Image
def myPutText(src, text, pos, font_size, font_color):
    img_pil = Image.fromarray(src)
    draw = ImageDraw.Draw(img_pil)
    font = ImageFont.truetype('font/gulim.ttc', font_size) # font 없어서 출력 안되는 듯?
    draw.text(pos, text, font=font, fill=font_color)
    return np.array(img_pil)

Font_size = 30
color2 = (0, 0, 255)
myPutText(img1, "코딩", (20, 50), Font_size, color2)  # 함수르 사용하여 한글 지원cv2.imshow('img', img)

cv2.imshow('img1', img1)
cv2.imshow('img', img)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
# resize
import cv2

img = cv2.imread('../../img.jpg')

dst = cv2.resize(img, (400, 500))
# 고정 픽셀 말고 비율로 설정, 보간법 : INTER_AREA(줄일 때), INTER_CUBIC(늘릴 때)  
dst1 = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_CUBIC)

cv2.imshow('img', img)
cv2.imshow('dst', dst)
cv2.imshow('dst1', dst1)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
# 동영상 resize
import cv2

cap = cv2.VideoCapture('../../video.mp4')

while cap.isOpened(): # 처리해주는게 좋음
    ret, frame = cap.read()
    if not ret:
        break
    frame_resize = cv2.resize(frame, None, fx=0.3, fy=0.3, interpolation=cv2.INTER_AREA)
    
    cv2.imshow('frame', frame_resize) # 컬러 
    if cv2.waitKey(1) == ord('q'):
        break
        
cap.release()
cv2.destroyAllWindows()
```


# 임계값(Thresholding), 마스킹(Masking) 및 관심영역(Region of Interest)

이미지 변경 흐림
cv2.blur(), cv2.GaussianBlur()

```python
import cv2

img_file = '../../img.jpg'
img = cv2.imread(img_file)
dst = cv2.blur(img, (9, 9), anchor=(-1, -1), borderType=cv2.BORDER_DEFAULT) # anchor(-1, -1)은 알아서 중심점 찾으라는 의미  
cv2.imshow('img', img)
cv2.imshow('dst', dst)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
import cv2

img_file = '../../img.jpg'
img = cv2.imread(img_file)

# img, kernel, 표준편차 / kernel만 명시
# kernel_3 = cv2.GaussianBlur(img, (3, 3), 0) # 0 알아서 구하라는 의미
# kernel_5 = cv2.GaussianBlur(img, (5, 5), 0)
# kernel_7 = cv2.GaussianBlur(img, (7, 7), 0)

# 위와 비슷하게 나옴 / 표준편차만 명시
kernel_3 = cv2.GaussianBlur(img, (0, 0), 1)
kernel_5 = cv2.GaussianBlur(img, (0, 0), 2)
kernel_7 = cv2.GaussianBlur(img, (0, 0), 3)

cv2.imshow('kernel_3', kernel_3)
cv2.imshow('kernel_5', kernel_5)
cv2.imshow('kernel_7', kernel_7)

cv2.waitKey(0)
cv2.destroyAllWindows()
```


## 관심영역만 표시 - threshold()
[이미지 임계처리](https://opencv-python.readthedocs.io/en/latest/doc/09.imageThresholding/imageThresholding.html)

```python
import cv2

img_file = '../../book.jpg'
img = cv2.imread(img_file, cv2.IMREAD_GRAYSCALE)
# 임계값 ret와 binary 이미지 binary 2개 값을 반환
# 127보다 큰 값은 255로 치환
ret, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

cv2.imshow('img', img)
cv2.imshow('binary', binary)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### trackbar

```python
import cv2
def empty(pos):
    print(pos)
    pass

img_file = '../../book.jpg'
img = cv2.imread(img_file, cv2.IMREAD_GRAYSCALE)
name = 'Trackbar'

cv2.namedWindow(name)
cv2.createTrackbar('threshold', name, 127, 255, empty) # bar이름, 창이름, 초기값, 최대값, 이벤트처리

while True:
    thresh = cv2.getTrackbarPos('threshold', name) # bar이름, 창이름
    ret, binary = cv2.threshold(img, thresh, 255, cv2.THRESH_BINARY)
    
    if not ret:
        break
        
    cv2.imshow(name, binary)
    
    if cv2.waitKey(1) == ord('q'):
        break

cv2.destroyAllWindows()
```


## 경계선 검출 - Canny()

```python
import cv2

img_file = '../../snowman.png'
img = cv2.imread(img_file)
resized_img = cv2.resize(img, (300, 300))
img_gray = cv2.imread(img_file, cv2.IMREAD_GRAYSCALE)
resized_img_gray = cv2.resize(img_gray, (300, 300))

canny1 = cv2.Canny(resized_img, 150, 200)
canny2 = cv2.Canny(resized_img_gray, 150, 200)

cv2.imshow('resized_img', resized_img)
cv2.imshow('resized_img_gray', resized_img_gray)
cv2.imshow('canny1', canny1)
cv2.imshow('canny2', canny2)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

## 이미지 검출 - 윤곽선

```python
import cv2

img_file = '../../card.png'
img = cv2.imread(img_file)
dst_img = img.copy() # deep copy 데이터 자체가 복제

# 회색조 이미지 변경
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 이진화 / OTSU -> trackbar로 살펴보지 않아도 최적의 임계값을 찾아주는 알고리즘
ret, otsu = cv2.threshold(img_gray, -1, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
# 윤곽선 찾기 findContours
contours, hier = cv2.findContours(otsu, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)

c = (0, 200, 2) # color
# 윤곽선 그리기
cv2.drawContours(dst_img, contours, -1, c, 2) # target img, 2는 fitness

cv2.imshow('img', img)
cv2.imshow('img_gray', img_gray)
cv2.imshow('otsu', otsu)
cv2.imshow('contours', dst_img)


cv2.waitKey(0)
cv2.destroyAllWindows()
```

```python
import cv2
img = cv2.imread('./cv_data/card.png')
target_img = img.copy()  # 사본이미지

gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
ret, otsu = cv2.threshold(gray, -1, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU )

contours , hierarchy = cv2.findContours(otsu, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
COLOR = (0, 200, 2) # 녹색

# 윤곽선 있는 부분의 사각형 그리기
for cnt in contours:
    # if cv2.contoursArea(cnt) > 25000: 처럼 크기를 지정할 수 있음
    x, y, width, height = cv2.boundingRect(cnt)
    cv2.rectangle(target_img, (x, y), (x+width, y+ height), COLOR, 2)

cv2.imshow('img', img)
cv2.imshow('gray', gray)
cv2.imshow('otsu', otsu)
cv2.imshow('contour', target_img)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

이진화(흑백)하고 윤곽선 찾고 그리기
