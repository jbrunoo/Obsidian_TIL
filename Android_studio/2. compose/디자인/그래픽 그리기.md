[공식문서](https://developer.android.com/jetpack/compose/graphics/draw/overview?hl=ko)

Canvas를 이용해 그리거나 modifier 수정자 활용(`Modifier.drawWithContent`, `Modifier.drawBehind`, `Modifier.drawWithCache`)

modifier 활용하면 DrawScope라는 자체 상태를 가지고 있음.

좌표계는 Offset 활용.

```kotlin
@Composable  
fun Canvas(modifier: Modifier, onDraw: DrawScope.() -> Unit) =  
Spacer(modifier.drawBehind(onDraw))v
```
Canvas도 drawBehind를 둘러싼 편리한 래퍼일 뿐임.

- - - 
[공식문서](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).pointerInteropFilter(androidx.compose.ui.input.pointer.RequestDisallowInterceptTouchEvent,kotlin.Function1))
그림판 같은 실시간으로 그릴 때 
수정자에서 제공하는 두 가지 pointerInput과 pointerInteropFilter 두가지를 찾음

pointerInput은 pointerInputScope 안에서 포인터 입력 처리.
```kotlin
// 캡쳐된 값 변경 시, block 취소 후 restart 
@Composable
fun MyComposable(parameter: String) {
    Box(
        Modifier.fillMaxSize()
            .pointerInput(parameter) {
                detectTapGestures {
                    performAction(parameter)
                }
            }
    )
}

// 캡쳐된 값 변경 시 restart 하지 않고 계속 업데이트하는 경우
@Composable
fun MyComposable(parameter: String) {
    val currentParameter by rememberUpdatedState(parameter) // rememberUpdateState
    Box(
        Modifier.fillMaxSize()
            .pointerInput(Unit) {
                detectTapGestures {
                    performAction(currentParameter)
                }
            }
    )
}
```


pointerInteropFilter는 MotionEvent(down, move, up 등)를 핸들링하고 consume 하기 위함.
boolean 값을 반환하던데 consume을 어떻게 처리해야할지 정확한 정보를 못찾음.
canvas 안에서도 motionEvent에 따라 처리를 해주어야 할 것 같음.
pointerInput이 권장됨.
Prefer `pointerInput` and use this only for interoperation with existing code that consumes `MotionEvents`.