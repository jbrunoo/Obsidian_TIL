```kotlin
// 기본 readline() - null 허용, readln() - null x
// bufferedReader로 입력받기 - Scanner보다 빠름.
val br = BufferedReader(InputStreamReader(System.`in`)) // `in`은 예약어 의미
br.readLine()
br.flush()
br.close()
// 숫자 한 개
val n = br.readLine().toInt()
// 2 개 이상
val (n, m) = br.readLine().split(' ').map { it.toInt() }
// 많은 경우
var list = br.readLine().split(' ')

// 출력
// 기본 println()
// BufferedReader
val bw = BufferedWriter(OutputStreamWriter(System.out))
bw.write()
bw.close()
// StringBuilder - string 수정 많은 경우에도 유용.
val sb = StringBuilder()
for(i in 0..10000){
	sb.append("0\n")
}
println(sb)
```



[BufferedReader](https://noapps-code.tistory.com/128#article-1-4--5--bufferedreader)
- 기본적으로 바이트 스트림인 InputStream을 통해 바이트 단위로 데이터를 입력 받는다.
- 입력 데이터를 char 형태로 처리하기 위해 중개자 역할인 문자스트림 InputStreamReader를 사용한다.
InputStream -> Byte Type -> InputSreamReader -> Char Type -> BufferReader -> String Type (char 의 직렬화)
```kotlin
import java.io.BufferedReader 
import java.io.BufferedWriter 
import java.io.InputStreamReader 
import java.io.OutputStreamWriter 
fun main() { 
// BufferedReader 생성 
	val br = BufferedReader(InputStreamReader(System.`in`)) 
	// BufferedWriter 생성 
	val bw = BufferedWriter(OutputStreamWriter(System.out)) 
	try { 
		// 표준 입력에서 한 줄 읽기 
		val inputLine = br.readLine() 
		// 표준 출력에 한 줄 쓰기 
		bw.write(inputLine) 
		bw.newLine() // 개행 문자 쓰기 
		// 버퍼 비우기 (데이터를 실제 출력으로 보내기) 
		bw.flush() 
	} catch (e: Exception) {
		e.printStackTrace() 
	} finally { 
	// 사용한 자원 닫기 
		br.close() 
		bw.close() 
	} 
}
```

자바느낌이 들긴 함. with 같은 scope 함수 사용. + readln()

