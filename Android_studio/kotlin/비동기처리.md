scope, LaunchedEffect()


`rememberCoroutineScope`나 `viewModelScope` 등을 사용하는 경우에는 개발자가 직접 Coroutine Scope를 생성하고 관리


`LaunchedEffect`를 사용하는 경우, 해당 효과는 컴포저블이 라이프사이클에 따라 자동으로 관리되므로 개발자가 별도의 Coroutine Scope를 만들 필요가 없음.


결론 : `LaunchedEffect`는 Compose 라이프사이클과 통합되어 더 쉽게 사용할 수 있는 반면, 직접 Coroutine Scope를 사용하는 것은 더 많은 제어를 제공


`LaunchedEffect`의 파라미터는 특정 상태나 이벤트의 변경을 감지하는데 사용.
예를 들어, 특정 값을 넣으면 그 값이 변경될 때마다 `LaunchedEffect`가 실행. 
만약 `Unit`을 사용한다면, 이 효과는 컴포저블이 처음으로 실행될 때만 실행.
따라서 `LaunchedEffect(Unit)`은 초기화 이벤트에 반응하도록 설계된 것.
상태나 이벤트에 따라서 특정 작업을 실행하고자 할 때는 해당 상태나 이벤트를 파라미터로 전달하여 사용할 수 있음.


lazycolumn items{} 안에서 scope.launch(Dispatchers.IO) 오류.
이유는 다음과 같음. 
따라서 메인 스레드 이외에서 비동기 작업을 수행하는 것은 `scope.launch`나 `withContext`를 사용하여 안전하게 처리할 수 있습니다. 그러나 Compose의 특정 부분(예: `LazyColumn`의 `items` 블록)에서 직접 `scope.launch`를 사용하면 Compose의 비동기 작업 규칙을 위반하게 됩니다. 이 규칙은 Compose이 UI를 안전하게 관리하고 예상치 못한 문제를 방지하기 위한 것입니다.
LaunchedEffect()에서 withContext(Dispatchers.IO) {} 이용하여 해결.


luanch 함수의 job, async 함수의 Deferred [블로그 글](https://hodie.tistory.com/85) [velog 글](https://velog.io/@jkh9615/kotlin-Coroutine-%EC%9E%85%EB%AC%B8-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC)

scope.launch {  
    withContext(Dispatchers.IO) {  
        db.assistantDao().deleteAssistant(Assistant(currentUid + matchedCharacter.assistantId, currentUid))  
    }  
}
여기 안에서도 withContext를 쓸 수 있음
launch(Dispatcher.IO)를 실행하는 것은 새로운 코루틴을 실행하는 것이고 비동기로 코루틴 실행 및 완료 기다리지 않고 다음 코드 진행.
launch 안에서 withContext는 특정 문맥에서 코드 블록 실행.
그리고 코드 블록이 완료될 때 까지 대기.

runBlocking {}
작업이 완료될 때 까지 현재 스레드를 중단함. Coroutine의 목적과 맞지 않고 공식 문서도 사용 지양.
본래 blocking 형태로 제공되는 라이브러리와 연동을 위해 구현되었음. main과 text 코드에서 권장.

withContext 
- CoroutineScope 내에서 다른 context로 전환이 필요할 때,
- CoroutineScope 내에서 순서의 보장이 필요할 때(일시 중단하고 결과 값을 반환하므로)
runBlocking과 차이점은 현재 스레드를 완전 중단이 아닌 일시 중단한다는 점.

async, launch
CoroutineScope.async / CoroutineScope.launch
- async
    - block 함수가 T를 반환
    - Deffered<T>를 반환
    - 즉, 비동기 작업의 결과값을 받을 수 있다.
- launch
    - block 함수의 반환형이 없음 (Unit)
    - Job 객체를 반환
    - 결과값을 받지 못한다.

CoroutineContext
코루틴의 실행을 제어하고 관리하는데 사용. Dispatcher, Job을 조합하여 구성할 수 있음.
- Job : 코루틴의 작업을 관리하는데 사용 (`join()`, `cancel()`, `cancelAndJoin()`, `isActive`, `isCancelled`, `isCompleted`...)
- Dispatcher : 코루틴이 실행되는 스레드를 제어하는 데 사용 (`Dispatchers.Default`, `Dispatchers.IO`...)
(코루틴이 실행되는 스레드 pool) 기본 제공 Default, Main, IO, Unconfined


