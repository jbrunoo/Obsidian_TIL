요소들의 누적된 합의 의미.
어떠한 배열을 기반으로 앞에서 부터 요소들의 누적된 합을 저장해 새로이 배열을 만들어서 이를 활용하는 것

prefix sum(앞부터 더함)
보통 0번째 배열에는 값을 저장 x 그래야 편함.

suffix sum(뒤부터 더함, 코테에는 안나옴, 알고리즘 대회용)

배열 값이 변하지 않는 정적 배열에서 사용(동적 배열이면 펜윅트리)

단순하게 구현
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int a[100004], b, c, psum[100004], n, m;
int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
	}
	for(int i = 1; i < m; i++){
		cin >> b >> c;
		int sum = 0;
		for(int j = b; j <= c; j++) sum += a[j];
		cout << sum << '\n';
	}
	return 0;
}
```
누적합없이 10만의 데이터가 주어지면 10만 x 10만 = 100억 안돌아감.

반복문을 계속 돌리지 않고 psum[1], psum[2] (1+2 의미) 이런식으로 저장해두면 2~5 구간 쿼리의 값을 구할 때, psum[5] - psum[2] 하면 됨.

prefix sum
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int a[100004], b, c, psum[100004], n, m;
int main(){
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> n >> m;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
		psum[i] = psum[i - 1] + a[i]
	}
	for(int i = 0; i < m; i++){
		cin >> b >> c;
		cout << psum[c] - psum[b - 1] << "\n";
	}
	return 0;
}
```

