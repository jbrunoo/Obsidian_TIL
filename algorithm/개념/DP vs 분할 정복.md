#### 동적 계획법(DP; Dynamic Programming)
	주어진 문제를 작은 문제로 나누어 푸는 알고리즘
	ex) 피보나치 수열
	조건 : 최적 부분 구조(Optimal Substructure), 중복된 하위 문제들(Overlapping Subproblems)
	최적 부분 구조 : 서울 - 부산 - 대구 라면 서울 - 부산 과 부산 - 대구의 해가 합쳐짐
	중복된 하위 문제 : 중복이므로 다른 부분 문제에 재사용 가능함 (점화식이 같음)

	메모이제이션(Memoization) or 캐싱(Caching)
	부분 문제의 해는 늘 같은 값을 가지며, 다른 문제에 재사용 됨
	같은 값이고 재사용 되므로 부분 문제의 해를 저장하기 위해서 메모이제이션 방식 사용

	분할 정복과 차이점 ?
	오히려 공통점이 부분 문제로 나눈다 밖에 없음
	분할 정복에서는 부분 문제가 절대 중복되지 않음. 즉, 해를 재사용할 수 없음
	즉, 메모이제이션 방식 사용 불가능


#### DP 구현
	1. 상향식 (재귀 호출)
	
```kotlin
val memo = Array<Int>()
```


	2. 하향식 (반복문 사용)
	
```kotlin
```