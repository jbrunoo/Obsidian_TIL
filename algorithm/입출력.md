```kotlin
// 기본 readline() - null 허용, readln() - null x
// bufferedReader로 입력받기 - Scanner보다 빠름.
val br = BufferedReader(InputStreamReader(System.`in`)) // `in`은 예약어 의미
br.readLine()
br.flush()
br.close()
// 숫자 한 개
val n = br.readLine().toInt()
// 2 개 이상
val (n, m) = br.readLine().split(' ').map { it.toInt() }
// 많은 경우
var list = br.readLine().split(' ')

// 출력
// 기본 println()
// BufferedReader
val bw = BufferedWriter(OutputStreamWriter(System.out))
bw.write()
bw.close()
// StringBuilder - string 수정 많은 경우에도 유용.
val sb = StringBuilder()
for(i in 0..10000){
	sb.append("0\n")
}
println(sb)
```



[BufferedReader](https://noapps-code.tistory.com/128#article-1-4--5--bufferedreader)
- 기본적으로 바이트 스트림인 InputStream을 통해 바이트 단위로 데이터를 입력 받는다.
- 입력 데이터를 char 형태로 처리하기 위해 중개자 역할인 문자스트림 InputStreamReader를 사용한다.
InputStream -> Byte Type -> InputSreamReader -> Char Type -> BufferReader -> String Type (char 의 직렬화)
```kotlin
import java.io.BufferedReader 
import java.io.BufferedWriter 
import java.io.InputStreamReader 
import java.io.OutputStreamWriter 
fun main() { 
// BufferedReader 생성 
	val br = BufferedReader(InputStreamReader(System.`in`)) 
	// BufferedWriter 생성 
	val bw = BufferedWriter(OutputStreamWriter(System.out)) 
	try { 
		// 표준 입력에서 한 줄 읽기 
		val inputLine = br.readLine() 
		// 표준 출력에 한 줄 쓰기 
		bw.write(inputLine) 
		bw.newLine() // 개행 문자 쓰기 
		// 버퍼 비우기 (데이터를 실제 출력으로 보내기) 
		bw.flush() 
	} catch (e: Exception) {
		e.printStackTrace() 
	} finally { 
	// 사용한 자원 닫기 
		br.close() 
		bw.close() 
	} 
}
```

위 코드는 자바느낌이 들긴 함. with 같은 scope 함수 사용. + readln()


#### 새로 정리
- - - 
```kotlin
// 1. import java.util.Scanner 라이브러리
val sc = Scanner(System.`in`)
val a = sc.nextInt()

// 2. readline() - null허용, readln() - null x
val str =readln()

// 3. import java.io.BufferedReader
// 3. import java.io.InputStreamReader
val br = BufferedReader(InputStreamReader(System.`in`)) // `은 in이 kotlin의 키워드라 구분용
val str = br.readline()

// 3.5 import 없이 간결하게 선언 가능. 위에 똑같은 기능.
val br = System.`in`.BufferedReader()

// 4. bufferedWriter
val bw = System.out.BufferedWriter()
bw.write("hi\n")
bw.write(5555)
bw.write("hello")
bw.flush() // 위에 write는 버퍼에 담아 두다가 flush가 호출되어야 출력됨
bw.close() // close는 flush + close 됨.
// 그렇다면 close만 쓰지 않고 flush도 쓰는 이유 ?
// -> 1. close로 스트림 닫지 않고 유지하면서 출력하고 싶을 때
// -> 2. 버퍼 size는 8192. 스트림을 유지하면서 버퍼 size 내에서 조절하기 위해
```

입력 : bufferedReader는 scanner보다 7배 빠르다.
출력 : bufferedWriter는 println() 보다 30배 빠르다.

결론 : 코테 시 사용
