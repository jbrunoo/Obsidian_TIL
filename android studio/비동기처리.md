scope, LaunchedEffect()


`rememberCoroutineScope`나 `viewModelScope` 등을 사용하는 경우에는 개발자가 직접 Coroutine Scope를 생성하고 관리


`LaunchedEffect`를 사용하는 경우, 해당 효과는 컴포저블이 라이프사이클에 따라 자동으로 관리되므로 개발자가 별도의 Coroutine Scope를 만들 필요가 없음.


결론 : `LaunchedEffect`는 Compose 라이프사이클과 통합되어 더 쉽게 사용할 수 있는 반면, 직접 Coroutine Scope를 사용하는 것은 더 많은 제어를 제공


`LaunchedEffect`의 파라미터는 특정 상태나 이벤트의 변경을 감지하는데 사용.
예를 들어, 특정 값을 넣으면 그 값이 변경될 때마다 `LaunchedEffect`가 실행. 
만약 `Unit`을 사용한다면, 이 효과는 컴포저블이 처음으로 실행될 때만 실행.
따라서 `LaunchedEffect(Unit)`은 초기화 이벤트에 반응하도록 설계된 것.
상태나 이벤트에 따라서 특정 작업을 실행하고자 할 때는 해당 상태나 이벤트를 파라미터로 전달하여 사용할 수 있음.


lazycolumn items{} 안에서 scope.launch(Dispatchers.IO) 오류.
이유는 다음과 같음. 
따라서 메인 스레드 이외에서 비동기 작업을 수행하는 것은 `scope.launch`나 `withContext`를 사용하여 안전하게 처리할 수 있습니다. 그러나 Compose의 특정 부분(예: `LazyColumn`의 `items` 블록)에서 직접 `scope.launch`를 사용하면 Compose의 비동기 작업 규칙을 위반하게 됩니다. 이 규칙은 Compose이 UI를 안전하게 관리하고 예상치 못한 문제를 방지하기 위한 것입니다.
LaunchedEffect()에서 withContext(Dispatchers.IO) {} 이용하여 해결.


luanch 함수의 job, async 함수의 Deferred [블로그 글](https://hodie.tistory.com/85)

