## 모듈 구현

#### 단위 모듈 구현 ★★
	소프트웨어 개발에 기능을 단위 모듈별로 분할, 추상화하여 성능 향상, 유지보수에 효과적인 구현 기법
	모듈은 소프트웨어 구조를 이루며 다른 것들과 구별될 수 있는 독립적인 기능을 이루는 단위
	인터페이스 모듈, 데이터베이스 접근 모듈 등 통합 구현에 필요한 단위 컴포넌트를 구현
	ps. 컴포넌트
		모듈들의 집합. 특정한 기능을 수행하기 위해 독립적으로 개발, 보급. 
		다른 부품과 조립되어 사용되는 소프트웨어 프로그램
	ps2. 컴포넌트와 모듈의 차이
		컴포넌트는 '런타임'에 독립적 배포, 실행 단위 / 모듈은 정적인 구조
		ex) 하나의 서버에 5개의 클라로 정보 제공하는 경우, 
		모듈은 2개(서버 1, 클라 1), 컴포넌트는 6개(서버 1, 클라 5)
		헷갈린다면 모듈은 실제 구현된 것이고 컴포넌트는 동작하는 모듈의 수
	
	
	단위 모듈 구현의 원리
	정보 은닉(Information Hiding)
		어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 은폐
	분할과 정복(Dvide & Conquer)
		복잡한 문제를 분해, 모듈 단위로 문제 해결
	데이터 추상화(Data Abstraction)
		각 모듈 자료 구조를 액세스하고 수정하는 함수 내에 자료 구조의 표현 내역을 은폐
	모듈 독립성(Module Independency)
		낮은 결합도, 높은 응집도
	
	구현 단계에서 작업 절차
	코딩 계획 - 코딩 - 컴파일 - 테스트
	코딩 절차에서 프로그래밍 언어 선택 시 개발 정보시스템 특성, 사용자 요구사항, 컴파일러 가용성 고려
	
	재사용 기법
	재사용 : 이미 개발되어 그 기능, 성능, 품질을 인정 받았던 소프트웨어의 전체 or 일부분을 다시 사용
	재사용 종류 : 단위 모듈의 재사용성의 개념이 확장된 재공학, 재개발 기법 존재 (실기 출제 가능성)
		재공학
			기존 소프트웨어 버리지 않고 기능 개선 or 기능을 새로운 소프트웨어로 재활용
			주요 활동 : 분석, 재구조, 역공학, 이식
		재개발
		기존 시스템 내용을 참조하여 완전히 새로운 시스템 개발. 새로운 기능 추가 or 기존 기능 변경
	재사용 규모에 따른 분류
		함수와 객체 : 함수나 메서드 단위의 소스 코드 재사용
		컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
		애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용

#### 단위 모듈 테스트
	모듈의 개별적인 코드 단위가 예상대로 작동하는지 확인하는 기법
	단위 모듈 테스트를 위해 IDE 도구를 활용하여 개별 단위 모듈에 대한 디버깅 수행
	ps. 테스트는 오류를 찾는 작업 / 디버그는 오류를 수정하는 작업
	
	단위 모듈 테스트의 종류
		블랙박스 테스트(= 명세 기반 테스트)
		프로그램 외부 사용자의 요구사항 명세서를 보면서 수행하는 테스트(기능 테스트)
		화이트박스 테스트(= 구조 기반 테스트)
		모듈 내부의 소스를 보면서 수행하는 테스트(테스트 케이스를 다양하게 만들어 수행)


## 통합 구현 관리
#### IDE 도구
	코딩, 디버그, 컴파일, 배포 등 프로그램 개발과 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을 제공하는 소프트웨어
	기존에는 컴파일러, 텍스트 편집기, 디버거를 따로 사용함.
	
	IDE 도구의 기능
		개발환경 지원
		컴파일 (문법에 어긋나는지 확인 및 기계어로 변환하는 기능 제공)
		디버깅 (프로그래밍 과정에서 발생하는 오류 및 비정상적인 연산 제거)
		외부 연계 (외부 형상, 배포관리 기능과 연계되어 자동 배포 등이 가능) 
		DB 연동 (JDBC, ODBC 등)
	
	IDE 도구 : 이클립스, 비주얼 스튜디오, 엑스 코드 등
	
#### 협업 도구
	다른 개발자와 유대감을 형성 or 개발 관련 소통을 위해서 지속적으로 커뮤니케이션 수행하기 위한 도구
	통합 구현 관리를 위해 필요
	
	 렵업 도구의 분류(+도구)
		 문서 공유 - 구글 드라이브
		 소스 공유 - 깃허브
		 아이디어 공유 - 에버노트
		 디자인 공유 - 레드 펜
		 마인드 맵 - 마인드 마이스터
		 프로젝트 관리 - 트렐로(Trello), 레드마인(Redmine), 지라(JIRA)
		 일정 관리 - 구글캘린더
	
	기능 : 개발자 간 커뮤니케이션, 일정 및 이슈 공유, 개발자 간 집단 지성 활용

#### 형상 관리 도구
	형상 관리
	소프트웨어 생명주기 동안 발생하는 변경사항을 체계적 관리하여 폼질 보증을 향상시키는 관리적 활동
	관리 항목으로 프로젝트 요구 분석서, 소스 코드, 운영 및 설치 지침서가 있음
	유지보수 단계뿐 아니라 개발 단계에서도 사용 가능


	형살 관리 절차 : 형상 식별 - 형상 통제 - 형상 검사 - 형상 기록
	형상 통제에서 형상통제위원회가 승인/기각/보류 결정, 승인된 변경사항의 이행을 체계적으로 통제
	ps. 형상통제위원회(CCB; Change Control Board): 프로젝트 진행 과정에 변경사항 적용여부 결정 회의

	형상 관리 도구
	소프트웨어 변경 사항을 관리하기 위해서 형상 식별, 통제, 감사, 기록을 수행하는 도구
	소스 코드나 문서의 버전 관리, 이력 관리, 추적 등 변경 사항을 체계적으로 관리할 수 있는 기능 제공
	대표제품 : CVS, SVN, Git
	기능 
		체크인 - 수정한 소스를 형상 관리 저장소로 업로드
		체크아웃 - 형상 관리 저장소로부터 최신 버전을 개발자 PC로 다운로드 받는 기능
		커밋 - 소스를 형상 관리 저장소에 업로드 후 최종적으로 업뎃되었을 때 형상 관리 서버에 반영


	형상 관리 도구 사례
	CVS(Current Versions System)
		가장 오래된 형상 관리 도구. 중앙 집중형 서버 저장소 두고 클라이언트가 접속 -> 버전 관리 실행
		주요기능 : 변경사항 동기화, 파일 단위 관리
		장점 : 직관적, 비교적 단순한 명령 세트 
		단점 : 텍스트 기반, 등록된 파일 및 디렉토리 변동 불편, 커밋 실패 등 롤백 기능 미지원

	SVN(Subversion)
		중앙 집중형 클라이언트-서버 방식. CVS 단점을 보완해 가장 널리 사용되고 있는 형상 관리 도구
		주요 기능 : CVS 기능 제공, 바이너리 파일 관리, 롤백 기능 제공
		장점 : 디렉토리 파일 자유롭게 이동, CVS 비해 비약적 빨라진 속도, Gzip 압축하여 공간 절약, 다양한 플러그인 API 제공
		단점 : Trunk, Brunch, Tag가 모두 물리적 저장 위치 점유, 잦은 커밋으로 인해 리비전 번호가 크게 증가할 수 있음, 개별 개발자만의 개발 이력 가질 수 없음

	Git
		리누스 토발즈가 2005년 리눅스 커널 개발을 위해 만든 형상 관리 시스템
		주요 기능 : 로컬/원격 형상 관리, 롤백 기능 제공
		ps. Branch, Check-Out, Commit 등 로컬 환경 / Push, Fetch, Pull 등 원격 환경
		장점 : 저장소의 완전한 복사본을 로컬 저장 가능, 로컬 저장을 통해 오프라인 작업 가능, 일시적인 작업에 대한 이력 관리 쉬움
		단점 : 대용량 코드 관리 부적절, 한 번에 diff 명령어를 통한 변경 사항 보기 어려움, CVS, SVN과 개념이 상이하여 학습시간 요구

