## 공통 모듈 설계

#### 재사용
	목표 시스템의 개발 시간 및 비용 절감을 위하여 검증된 기능을 파악하고 재구성하여 시스템에 응용하기 위한 최적화 작업
	기존 소프트웨어 또는 소프트웨어 지식을 활용하여 새로운 소프트웨어를 구축하는 작업

	재사용 유형
		함수와 객체 재사용, 컴포넌트 재사용, 애플리케이션 재사용


#### 공통 모듈 ★★★
	모듈은 크게 독립된 하나의 소프트웨어 또는 하드웨어 단위를 지칭하는 용어
	모듈화를 통해 분리된 시스템의 기능들로 서브프로그램, 서브 루틴, 소프트웨어 내의 단위 프로그램, 작업 단위 등과 같은 의미로 사용

	특징 : 독립성, 다양한 조합, 재사용, 영향 최소화

	공통 모듈
		전체 프로그램 기능 중 특정 기능을 처리할 수 있는 실행 코드, 자체적으로 컴파일 가능, 다른 프로그램에서 재사용 가능, 날짜 처리를 위한 유틸리티 모듈 등 해당

	공통모듈 원칙 : 정확성 / 명확성 / 완전성 / 일관성 / 추적성  (정명 완일추)

	모듈화 : 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해, 추상화. 소프트웨어 제품의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리를 쉽게 하는 기법(기능 단위 분해하는 설계 및 구현 기법)

	모듈화 기법 : 루틴(메인 루틴 / 서브 루틴)
		루틴 : 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령들의 모임(메인은 서브 루틴을 호출)

	모듈화 필요성 : 모듈 크기가 작아 개수 많으면 통합 비용 증가, 크기가 크면 개발 비용 증가
		PS. 모듈 수 증가 시 상대적으로 모듈 크기가 작아지고 상호 교류 증가로 과부화(overload) 현상

	바람직한 모듈 설계 방안 ★★★
		모듈의 독립성과 재사용성을 높이기 위하여 결합도는 낮추고 응집도는 높인다.
		모듈의 복잡도와 중복성을 줄이고 일관성을 유지한다.
		모듈의 기능은 예측이 가능해야 하며, 지나치게 제한적이어서는 안 된다.
		적당한 모듈의 크기를 유지한다.
		모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.
		유지보수가 용이해야 하고, 이식성을 고려해야 한다.

	모듈화 측정 지표 : 응집도, 결합도
		응집도 : 모듈의 내부 요소들의 서로 관련되어 있는 정도(독립적인 기능으로 정의되어 있는 정도)
		결합도 : 모듈 간에 상호 의존하는 정도(두 모듈 사이의 연관 관계를 맺고 있는 정도)

	좋은 모듈화는 용도에 맞게 잘 구분된 기능을 가진 모듈들로 세분화, 개별 모듈은 독립적으로 주어진 역할만을 수행하며, 타 모듈에 의존성이 높지 않아야 함.

	모듈화 유형 - 응집도, 결합도 (같은 개념 반복 생략)
	응집도는 정보 은닉 개념의 확장 개념, 하나의 모듈은 하나의 기능 수행

	응집도 유형 ★★★  (우논시절 통순기)
		우연적 < 논리적 < 시간적 < 절차적 < 통신적 < 순차적 < 기능적 응집도 순으로 응집도 높아짐

	결합도는 모듈 내부가 아닌 외부의 모듈과의 연관도 or 모듈 간의 상호 의존성을 나타내는 정도
	소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도

	결합도 유형 ★★★  (내공 외제 스자)
		내용 > 공통 > 외부 > 제어 > 스탬프 > 자료 결합도 순으로 결합도 낮아짐



	팬인(Fan-In) 및 팬아웃(Fan-Out)
	팬인 : 어떤 모듈을 제어하는 모듈의 수 / 팬아웃 : 어떤 모듈에 의해 제어되는 모듈의 수

	 소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해서 팬인, 팬아웃 활용
	 시스템 복잡도를 최적화하기 위해 팬인은 높게, 팬아웃은 낮게 설계해야 함

	팬인 및 팬아웃 계산 방법 : 팬인은 모듈 자신 기준으로 들어올 때, 팬아웃은 나갈 때 +1


#### 설계 모델링
	요구사항 분석 단계에서 규명된 필수 기능들의 구체적인 구현 방법을 명시하는 기법

	설계 모델링 원칙
		소프트웨어 설계는 변경이 쉽도록 구조화되어야 함
		하나의 함수 안에 특정 기능을 수행하는데 필요한 자료만 사용하도록 규제
		독립적이고 기능적인 특성을 지닌 모듈 단위로 분할 설계
		계층적 구조를 가져야 함


	유형 : 구조 모델링 / 행위 모델링
		구조 모델링: 구조적인 관계, 특성들 모델링. 구성요소: 프로시저, 데이터 구조, 모듈, 파일 구조
			프로시저 : 프로그램을 기능에 따라 여러 개 단위로 분해하여 작성(서브 / 함수 프로시저)
		행위 모델링: 기능수행 순서, 상호작용 모델링. 구성요소: 입/출력 데이터, 데이터 흐름/변환/저장


	소프트웨어 설계 유형 : 자료 구조 / 아키텍처 / 인터페이스 / 프로시저 / 협약에 의한 설계
		협약에 의한 설계 : 클래스에 대한 여러 가정을 공유하도록 명세. 선행조건, 결과조건, 불변조건
	위 5개는 상위 설계(시스템 수준 컴포넌트 간 관계) / 모듈 설계는 하위 설계(내부 구조, 동적 행위 등)

	소프트웨어 설계 원리
		상향식 설계(Bottom-Up Design) / 하향식 설계(Top-Down Design)

	코드 설계
	데이터의 분류나 조합을 쉽게 하기 위하여 사물을 표현하는 코드를 설계하는 기법
	코드의 기능 : 표준화, 분류, 식별, 배열, 간소화, 연상, 암호화, 오류 검출 기능

	코드 설계 종류 : 연상 코드, 블록 코드, 순차 코드, 표의 숫자 코드, 십진 코드, 그룹 분류식 코드
		연상코드 : 코드만 보고 연상할 수 있도록 명칭 일부를 약호. (KR, US 등)
		블록 코드 : 공통성이 있는 것끼리 블록으로 구분, 블록 내에서 일련번호 (지역번호 - 국번)
		순차 코드 : 일정한 기준에 따라 순서대로 일련번호 (중고등 학생 반 번호 : 1번, 2번, 3번)
		표의 숫자 코드 : 대상 자료의 물리적인 수치인 길이, 넓이, 용량 등 
		십진 코드 : 10진수 형태로 표현한 코드
		그룹 분류식 코드 : 대상을 기준에 따라 대분류, 중분류, 소분류 (학번: 입학연도 - 일련번호)

	코드 설계 절차 : 코드화 항목 선정 - 코드화 목적 설정 - 코드화 대상 확인 - 코드화 범위 결정 - 코드 사용 기간 설정 - 코드화 항목의 특성 분석 - 코드화 방식 결정 - 문서화

	코드 오류 종류 : 사본 오류, 전위 오류, 생략 오류, 첨가 오류, 이중 전위 오류
		사본 오류 : 한 자리를 잘못 표기한 경우
		전위 오류 : 연속된 두 글자가 서로 바뀌어 표기된 오류
		생략 오류 : 한 글자를 빼먹고 기술한 경우
		첨가 오류 : 한 글자를 ㅊ ㅜ가되어 기술한 경우
		이중 전위 오류 : 전위 오류가 중복 발생한 경우


	HIPO(Hierarchy Input Process Output)
	시스템의 분석 및 설계, 문서화할 때 사용되며, 하향식 소프트웨어 개발을 위한 문서화 도구
	특징
		체계적인 문서 관리 가능, 기호/도표 등을 사용해서 보기가 쉽고 이해하기 쉬움
		기능과 자료의 의존 관계를 동시에 표현 가능, 변경/유지보수가 용이
		시스템의 기능을 고유 모듈로 분할하여 이들 간 인터페이스를 계층 구조로 표현한 것 == HIPO 차트
	HIPO 차트 종류 : 가시적 도표, 총체적 도표, 세부적 도표  (가총세)


#### 소프트웨어 아키텍처
	여러 가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템 구조
	소프트웨어를 설계하고 전개하기 위한 지침과 원칙

	필요성
		소프트웨어 아키텍처를 활용하여 주요 이해관계자들 간의 관점 조율을 통해 시스템을 최적화
		소프트웨어 아키텍처는 시스템의 비기능적인 요소에 집중해서 만들어지지만 기능적인 요소도 고려

	소프트웨어 아키텍처 4+1 뷰
	고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
	구성요소 : 1은 유스케이스 뷰, 4는 논리 뷰 / 구현 뷰 / 프로세스 뷰 / 배포 뷰
		유스케이스 뷰 : 시스템의 기능 요구사항을 보여주는데 초점, 다른 뷰를 검증하는데 사용
		논리 뷰 : 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
		프로세스 뷰 : 시스템의 비기능적인 속성. 효율적 자원 사용, 병행 실행, 비동기, 이벤트 처리 등
		구현 뷰 : 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
		배포 뷰 : 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰

	소프트웨어 아키텍처 비용 평가 모델
	아키텍처 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델
	비용 평가 모델 종류 : SAAM, ATAM, CBAM, ADR, ARID  (SACAA)
		SAAM(Software Architecture Analysis Method)
			변이 용이성과 기능성에 집중, 경험 없는 조직에서도 활용 가능
		ATAM(Architecture Trade-off Analysis Method)
			아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충 관계까지 평가
		CBAM(Cost Benefit Analysis Method)
			ATAM 바탕으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
		ADR(Active Design Review)
			소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
		ARID(Active Reviews for Intermediate Designs)
			전체 아키텍처가 아닌 특정 부분에 대한 품질 요소에 집중하는 비용 평가 모델

	소프트웨어 아키텍처 패턴
	외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조
	소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식
	일반적으로 발생하는 문제점들에 대해 일반화되고 재사용 가능한 솔루션

	패턴 유형 : 계층화, 클라이언트-서버, 파이프-필터, 브로커, 모델-뷰-컨트롤러, 마스터-슬레이브 패턴
	계층화 패턴
		시스템을 계층으로 구분. 하위 모듈-상위 계층. 서로 마주보는 두 개의 계층 사이에서만 상호 작용
	클라이언트-서버 패턴
		하나의 서버와 다수의 클라이언트로 구성. 서버는 계속 클라이언트로부터 요청을 대기
	파이프-필터 패턴
		데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 단방향 패턴
	브로커 패턴
		분리된 컴포넌트들로 이루어진 분산 시스템에 사용. 원격 서비스 실행을 통해 상호 작용
	모델-뷰-컨트롤러 패턴
		모델 : 핵심 기능과 데이터 보관 / 뷰 : 사용자에게 정보 표시 / 컨트롤러 : 사용자 요청 처리
	마스터-슬레이브 패턴
		실시간 시스템에 사용. 연산/통신/조정을 책임지는 마스터와 제어되고 동기화되는 대상인 슬레이브

	소프트웨어 아키텍처 품질 속성
	아키텍처 비용 평가를 위해서 필요한 사항으로 특정 품질에 대한 요구사항을 명세한 내용, 최적의 아키텍처를 선택하기 위한 핵심 요소 / 시스템 품질 속성, 비즈니스 품질 속성, 아키텍처 품질 속성으로 구성
		시스템 품질 속성 : 가변성, 변경 용이성, 성능, 보안성, 사용 편의성, 시험 용이성(가변성보사시)



#### 객체 지향 설계
	객체지향 : 실세계의 개체를 속성과 메서드가 결합한 형태의 객체로 표현하는 기법
	구성요소
		클래스, 객체, 메서드, 메시지(객체 간 상호작용), 인스턴스, 속성
	객체 지향 기법
		캡슐화(encapsulation) : 연관된 데이터와 함수를 묶어 외부와 경계, 필요한 인터페이스만 드러냄
		상속성(Inheritance)
		다형성(Polymorphism) : 오버로딩(같은 이름 메서드 매개변수 유형/개수 변화), 오버라이딩(상위 클래스에서 정의한 일반 메서드의 구현을 하위 클래스에서 무시하고 재정의)
		추상화(Abstraction) : 공통 성질 추출하여 추상 클래스 설정. 과정/자료/제어 추상화.  (과자제)
		정보 은닉(Information Hiding) : 공개 인터페이스 통해서만 접근이 가능하도록 코드 보안 기술.
		관계성(Relationship) : 두 개 이상의 엔터티 형에서 데이터를 참조하는 관계를 나타내는 기법.
			연관화(상호 의존성), 분류화(인스턴스), 집단화(상속x), 일반화(상속), 특수화(상속+수정)
	객체 지향 설계 원칙(SOLID)
		단일책임원칙(Single responsibility Principle)
		개방 폐쇄 원칙(Open Close Principle)
		리스코프 치환 원칙(Liscov Substitution Principle)
		인터페이스 분리 원칙(Interface Segregation Principle)
		의존성 역전 원칙(Dependency Inversion Principle)
			변화가 없는 것에 의존 관계를 맺자(추상클래스, 인터페이스)

	객체 지향 방법론 종류
		OOSE(Object Oriented Software Engineering) - 야콥슨, 유스케이스 활용
		OMT(Object Modeling Technology) - 럼바우, 그래픽 표기법, 분석 절차(객체/동적/기능 모델링)
		OOD(Object Oriented Design) - 부치, 다이어그램 중심 개발 방법론
		코든-요든(Coad-Yourdon) 방법론 - E-R 다이어그램 사용
		워프-브록(Wirfs-Brock) 방법론 - 분석, 설계 간 구분 x, 고객 명세서를 평가해서 설계 작업까지

#### 디자인 패턴
	소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법 정리
	구성요소 : 패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플 코드
	
	유형 : 생성(Creational)패턴, 구조(Structural)패턴, 행위(Behavioral)패턴
		생성 패턴 : 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식 구조화, 캡슐화 수행
		(빌브팩앱싱)
			Builder - 객체 생성 방법과 구현 방법을 분리(동일한 생성 절차에서 서로 다른 표현 결과)
			Prototype - 일반적인 원형 만들어두고 복사한 후 필요한 부분만 수정하여 사용
			Factory Method - 상위 클래스에서 객체 생성 인터페이스, 하위클래스에서 인스턴스 생성
			Abstract Factory - 구체적 클래스 의존 x, 서로 연관/의존 객체들 조합 인터페이스 제공
			Singleton - 전역 변수 사용 x, 객체를 하나만 생성, 생성된 객체를 어디에서든지 참조 가능
			
		구조 패턴 : 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
		(브데 퍼플 프롬 컴 어)
			Bridge - 기능의 클래스 계층과 구현의 클래스 계층을 연결, 구현부에서 추상 계층을 분리
			Decorator - 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴
			Facade - 복잡한 시스템에 단순한 인터페이스 제공. 결합도 낮추고 시스템 구조 파악 쉽게 함
			Flyweight - 다수 객체로 생성 시 모두 갖는 본질적 요소 클래스화/공유. '클래스의 경량화'
			Proxy - '실체 객체에 대한 대리 객체'. 미리 할당 x여도 상관없는 것들 실제 이용할 때
			Composite - 객체들 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴
			Adapter - 기존 생성된 클래스 재사용 위한 중간에서 맞춰주는 역할 인터페이스 만드는 패턴
			
		행위 패턴 : 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
			Mediator - 객체 수가 많아 통신 복잡할 때, 중재자를 두고 통신의 빈도수를 줄이기 위함
			Interpreter - 언어의 다양한 해석, 구체적 구문 나누고 분리된 구문 해석 클래스 각각 작성
			Iterator - 컬렉션 구현 방법 노출 않고 집합체 안에 모든 항목에 반복자 사용하여 접근
			Template Method - 어떤 작업 처리 일부분을 서브 클래스 캡슐화. 전체 수행 구조 변화 않고 특정 단계에서 수행하는 내역을 바꾸는 패턴
			Observer - 객체 상태 바뀌면 그 객체에 의존하는 다른 객체들에 연락가고 자동 내용 갱신
			State - 객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식
			Visitor - 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만듦. 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴
			Command - 실행될 기능을 캡슐화, 재사용성이 높은 클래스를 설계하는 패턴
			Strategy - 알고리즘 군을 정의(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화, 필요할 때 서로 교환하여 사용하는 패턴
			Memento - 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴
			Chain of Responsibility - 정적으로 어떤 기능에 대한 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데 이를 동적으로 연결되어 있는 경우따라 다르게 처리되도록 연결한 패턴

	디자인 패턴 장단점
		장점 : 요구사항 변경에 소스 코드 변경 최소화, 코드 품질 향상, 유연 대처, 범용적 코드 스타일 적용, 개발자 간 원활한 의사소통, 재사용을 통한 개발 시간 단축, 구조 파악 용이, 생산성 향상
		단점 : 객체 지향 설계/구현 위주로 사용, 초기 투자 비용 부담

